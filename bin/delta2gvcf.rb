#!/usr/bin/env ruby

require 'stringio'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'tmpdir'
require 'bio-mummer'
require 'bio'

class OptParser
  def self.parse(args)
    options = OpenStruct.new

    opt_parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{File.basename(__FILE__)} [options]"
      opts.separator ""
      opts.separator "Specific options:"

      opts.on("-d", "--delta FILENAME", "Delta file generated by nucmer") do |fn|
        pn = Pathname.new(fn)
        if pn.size?
          options.samplename = pn.basename(".delta")
          options.delta = pn
          match = pn.each_line.first.match(/(?<ref>\/.*) (?<qry>\/.*)/)
          if match
            ref = Pathname.new(match[:ref])
            if ref.size?
              options.ref = Hash[Bio::FlatFile.open(ref).map{|e| [e.entry_id, e.naseq]}]
            end
            
            qry = Pathname.new(match[:qry])
            if qry.size?
              options.qry = Hash[Bio::FlatFile.open(qry).map{|e| [e.entry_id, e.naseq]}]
            end
          end
        else
          $stderr.puts "Error: cannot read file #{fn}"
          exit(1)
        end
      end

      opts.on("-s", "--sample SAMPLENAME", "gVCF Sample name") do |samplename|
        options.samplename = samplename
      end
    end
    opt_parser.parse!(args)
    return options
  end
end
options = OptParser.parse(ARGV)

d = BioMummer::DeltaFile.new(StringIO.new(`delta-filter -r -q #{options.delta}`))

puts '##fileformat=VCFv4.1
##ALT=<ID=NON_REF,Description="Represents any possible alternative allele at this location">
##FILTER=<ID=LowQual,Description="Low quality">
##FORMAT=<ID=AD,Number=.,Type=Integer,Description="Allelic depths for the ref and alt alleles in the order listed">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Approximate read depth (reads with MQ=255 or with bad mates are filtered)">
##FORMAT=<ID=GQ,Number=1,Type=Integer,Description="Genotype Quality">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=MIN_DP,Number=1,Type=Integer,Description="Minimum DP observed within the GVCF block">
##FORMAT=<ID=PL,Number=G,Type=Integer,Description="Normalized, Phred-scaled likelihoods for genotypes as defined in the VCF specification">'
options.ref.each do |name, seq|
  puts "##contig=<ID=#{name},length=#{seq.length}>"
end
puts '##INFO=<ID=BaseQRankSum,Number=1,Type=Float,Description="Z-score from Wilcoxon rank sum test of Alt Vs. Ref base qualities">
##INFO=<ID=ClippingRankSum,Number=1,Type=Float,Description="Z-score From Wilcoxon rank sum test of Alt vs. Ref number of hard clipped bases">
##INFO=<ID=DP,Number=1,Type=Integer,Description="Approximate read depth; some reads may have been filtered">
##INFO=<ID=DS,Number=0,Type=Flag,Description="Were any of the samples downsampled?">
##INFO=<ID=END,Number=1,Type=Integer,Description="Stop position of the interval">
##INFO=<ID=HaplotypeScore,Number=1,Type=Float,Description="Consistency of the site with at most two segregating haplotypes">
##INFO=<ID=InbreedingCoeff,Number=1,Type=Float,Description="Inbreeding coefficient as estimated from the genotype likelihoods per-sample when compared against the Hardy-Weinberg expectation">
##INFO=<ID=MLEAC,Number=A,Type=Integer,Description="Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC), for each ALT allele, in the same order as listed">
##INFO=<ID=MLEAF,Number=A,Type=Float,Description="Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF), for each ALT allele, in the same order as listed">
##INFO=<ID=MQ,Number=1,Type=Float,Description="RMS Mapping Quality">
##INFO=<ID=MQ0,Number=1,Type=Integer,Description="Total Mapping Quality Zero Reads">
##INFO=<ID=MQRankSum,Number=1,Type=Float,Description="Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities">
##INFO=<ID=ReadPosRankSum,Number=1,Type=Float,Description="Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias">'
puts "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t#{options.samplename}"

d.alignments
  .group_by{ |alignment| alignment.refname }
  .sort_by{ |refname, alignments| refname }
  .each do |refname, alignments|

  clusters = Enumerator.new do |yielder|
    # We sweep along each of the reference sequences. The cursor tracks
    # our position as we go so we don't concatenate regions that are
    # actually overlapping.
    cursor = 1

    # The =alignments= object is an array of BioMummer::Alignment
    # objects that all match a particular scaffold.
    alignments
      .sort_by{ |alignment| alignment.refstart }.
      each do |aln|
      # Create Bio::Sequence::NA subsequences for the reference and
      # query. They are initially unaligned.
      refSeq = options.ref[aln.refname].subseq(aln.refstart, aln.refstop)
      qrySeq = options.qry[aln.qryname].subseq(aln.qrystart, aln.qrystop)
      qrySeq.complement! unless aln.strand

      # Do we have uncovered bases before the alignment starts? These
      # are detected as gaps between the cursor and the alignment start
      # site in the reference.
      gap_size = aln.refstart - cursor
      overlap_size = 0
      if gap_size > 0
        # There is a stretch of reference bases without an alignment
        gapSeq = options.ref[aln.refname].subseq(cursor, aln.refstart - 1)
        gapSeq
          .chars
          .zip(("-" * gapSeq.length).chars, Range.new(cursor, aln.refstart, true))
          .each{ |ary| yielder << ary }
        cursor = aln.refstart
      else
        overlap_size = cursor - aln.refstart
      end

      # Nucmer records insertions and deletions as a series of positive
      # and negative integers corresponding to how many steps along the
      # alignment until you get to the next gap in the reference
      # sequence (positive integer) or how many steps until the next gap
      # in the query (negative integer). BioMummer exposes these as the
      # alignments 'distances' array.
      # We walk along the Bio::Sequence::NA objects and insert gaps
      # (".") when needed. We store our current position in the
      # reference and the query in a two-element array.
      aln.distances.inject([0,0]) do |mem, distance_to_gap|
        if distance_to_gap > 0
          qrySeq.insert(mem[0] + distance_to_gap - 1, ".")
          [mem[0] + distance_to_gap, mem[1] + distance_to_gap]
        else
          refSeq.insert(mem[1] - distance_to_gap - 1, ".")
          [mem[0] - distance_to_gap, mem[1] - distance_to_gap]
        end
      end

      if overlap_size < refSeq.length
        i = aln.refstart - 1
        positions = refSeq.chars.map{ |base| base == '.' ? i : i+=1 }
        refSeq
          .chars
          .zip(qrySeq.chars, positions)
          .drop(overlap_size)
          .each{ |ary| yielder << ary }
      end
    end
  end

  cursor = 0
  stolen_zipped = [nil, nil, nil]
  chunked = clusters.find_all do |refBase, qryBase, position|
    if position > cursor || (position == cursor && refBase == ".")
      cursor = position
      true
    else
      false
    end
  end.chunk do |refBase, qryBase, position|
    # Classify runs of identiry, insertions, deletions or SNPs.
    if refBase == qryBase 
      :NO_VARIATION
    elsif qryBase == "-"
      :NO_COVERAGE
    elsif qryBase == '.'
      :DELETION
    elsif refBase == '.'
      :INSERTION
    else
      :SNP
    end
  end.to_a

  chunked.each_cons(2) do |current, upcoming|
    cur_class = current.first
    cur_zipped = current.last
    nxt_class = upcoming.first

    if nxt_class == :INSERTION || nxt_class == :DELETION
      stolen_zipped = cur_zipped.pop
      next if cur_zipped.length == 0
    end
    
    case cur_class
    when :NO_COVERAGE
      puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{cur_zipped.first.first.upcase}\t<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t0:0:0:0,0"
    when :NO_VARIATION
      puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{cur_zipped.first.first.upcase}\t<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t0:1:200:0,800"
    when :SNP
      cur_zipped.each do |refBase, qryBase, position|
        puts "#{refname}\t#{position}\t.\t#{refBase.upcase}\t#{qryBase.upcase},<NON_REF>\t.\t.\tEND=#{position}\tGT:DP:GQ:PL\t1:1:200:800,0,800"
      end
    when :INSERTION
      refSeq, qrySeq = cur_zipped.unshift(stolen_zipped).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
      puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t1:1:200:800,0,800"
    when :DELETION
      refSeq, qrySeq = cur_zipped.unshift(stolen_zipped).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
      puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t1:1:200:800,0,800"
    end
    cursor = [cursor, cur_zipped.last.last].max
  end

  # We iterated over the entries in a window of length two, outputting
  # the first in the pair. This leaves the last entry unobserved, so
  # we take special care to output it here
  cur_class, cur_zipped = chunked.last
  case cur_class
  when :NO_COVERAGE
    puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{cur_zipped.first.first.upcase}\t<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t0:0:0:0,0"
  when :NO_VARIATION
    puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{cur_zipped.first.first.upcase}\t<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t0:1:200:0,800"
  when :SNP
    cur_zipped.each do |refBase, qryBase, position|
      puts "#{refname}\t#{position}\t.\t#{refBase.upcase}\t#{qryBase.upcase},<NON_REF>\t.\t.\tEND=#{position}\tGT:DP:GQ:PL\t1:1:200:800,0,800"
    end
  when :INSERTION
    refSeq, qrySeq = cur_zipped.unshift(stolen_zipped).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
    puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t1:1:200:800,0,800"
  when :DELETION
    refSeq, qrySeq = cur_zipped.unshift(stolen_zipped).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
    puts "#{refname}\t#{cur_zipped.first.last}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{cur_zipped.last.last}\tGT:DP:GQ:PL\t1:1:200:800,0,800"
  end

  # It's likely that the alignments don't run to the end of the
  # scaffold, so we fill in to the scaffold end with the 'no coverage'
  # entry
  remaining = options.ref[refname].length - cursor
  if remaining > 0
    puts "#{refname}\t#{cursor+1}\t.\t#{options.ref[refname][cursor].upcase}\t<NON_REF>\t.\t.\tEND=#{options.ref[refname].length}\tGT:DP:GQ:PL\t0:0:0:0,0"
  end
end
