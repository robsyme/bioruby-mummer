#!/usr/bin/env ruby

require 'stringio'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'tmpdir'
require 'bio-mummer'
require 'bio'

class OptParser
  def self.parse(args)
    options = OpenStruct.new

    opt_parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{File.basename(__FILE__)} [options]"
      opts.separator ""
      opts.separator "Specific options:"

      opts.on("-d", "--delta FILENAME", "Delta file generated by nucmer") do |fn|
        pn = Pathname.new(fn)
        if pn.size?
          options.samplename = pn.basename(".delta")
          options.delta = pn
          match = pn.each_line.first.match(/(?<ref>\/.*) (?<qry>\/.*)/)
          if match
            ref = Pathname.new(match[:ref])
            if ref.size?
              options.ref = Hash[Bio::FlatFile.open(ref).map{|e| [e.entry_id, e.naseq]}]
            end
            
            qry = Pathname.new(match[:qry])
            if qry.size?
              options.qry = Hash[Bio::FlatFile.open(qry).map{|e| [e.entry_id, e.naseq]}]
            end
          end
        else
          $stderr.puts "Error: cannot read file #{fn}"
          exit(1)
        end
      end

      opts.on("-s", "--sample SAMPLENAME", "gVCF Sample name") do |samplename|
        options.samplename = samplename
      end
    end
    opt_parser.parse!(args)
    return options
  end
end
options = OptParser.parse(ARGV)

d = BioMummer::DeltaFile.new(StringIO.new(`delta-filter -r -q #{options.delta}`))

puts '##fileformat=VCFv4.1
##ALT=<ID=NON_REF,Description="Represents any possible alternative allele at this location">
##FILTER=<ID=LowQual,Description="Low quality">
##FORMAT=<ID=AD,Number=.,Type=Integer,Description="Allelic depths for the ref and alt alleles in the order listed">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Approximate read depth (reads with MQ=255 or with bad mates are filtered)">
##FORMAT=<ID=GQ,Number=1,Type=Integer,Description="Genotype Quality">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=MIN_DP,Number=1,Type=Integer,Description="Minimum DP observed within the GVCF block">
##FORMAT=<ID=PL,Number=G,Type=Integer,Description="Normalized, Phred-scaled likelihoods for genotypes as defined in the VCF specification">'

options.ref.each do |name, seq|
  puts "##contig=<ID=#{name},length=#{seq.length}>"
end

puts '##INFO=<ID=BaseQRankSum,Number=1,Type=Float,Description="Z-score from Wilcoxon rank sum test of Alt Vs. Ref base qualities">
##INFO=<ID=ClippingRankSum,Number=1,Type=Float,Description="Z-score From Wilcoxon rank sum test of Alt vs. Ref number of hard clipped bases">
##INFO=<ID=DP,Number=1,Type=Integer,Description="Approximate read depth; some reads may have been filtered">
##INFO=<ID=DS,Number=0,Type=Flag,Description="Were any of the samples downsampled?">
##INFO=<ID=END,Number=1,Type=Integer,Description="Stop position of the interval">
##INFO=<ID=HaplotypeScore,Number=1,Type=Float,Description="Consistency of the site with at most two segregating haplotypes">
##INFO=<ID=InbreedingCoeff,Number=1,Type=Float,Description="Inbreeding coefficient as estimated from the genotype likelihoods per-sample when compared against the Hardy-Weinberg expectation">
##INFO=<ID=MLEAC,Number=A,Type=Integer,Description="Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC), for each ALT allele, in the same order as listed">
##INFO=<ID=MLEAF,Number=A,Type=Float,Description="Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF), for each ALT allele, in the same order as listed">
##INFO=<ID=MQ,Number=1,Type=Float,Description="RMS Mapping Quality">
##INFO=<ID=MQ0,Number=1,Type=Integer,Description="Total Mapping Quality Zero Reads">
##INFO=<ID=MQRankSum,Number=1,Type=Float,Description="Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities">
##INFO=<ID=ReadPosRankSum,Number=1,Type=Float,Description="Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias">'
puts "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t#{options.samplename}"

def vcf_array(type, refbases, qrybases, refname, cursor, length)
  if refbases.first.nil?
    p type, refbases, qrybases, refname, cursor, length
    raise "I can't even"
  end
  case type
  when :NOVAR
    return [refname, cursor,".", refbases.first.upcase, "<NON_REF>", '.', '.', "END=#{cursor + length - 1}", "GT:DP:GQ:MIN_DP:PL", "0:200:200:200:0,800"]
  when :SNP
    return [refname, cursor,".", refbases.join.upcase, "#{qrybases.join.upcase},<NON_REF>", '.', '.', "END=#{cursor + length - 1};CLASS=SNP", "GT:DP:GQ:MIN_DP:PL", "1:200:200:200:800,0,800"]
  when :DELETION
    return [refname, cursor,".", refbases.join.upcase, "#{qrybases.join.upcase},<NON_REF>", '.', '.', "END=#{cursor + length - 1};CLASS=DEL", "GT:DP:GQ:MIN_DP:PL", "1:200:200:200:800,0,800"]
  when :INSERTION
    return [refname, cursor,".", refbases.join.upcase, "#{qrybases.join.upcase},<NON_REF>", '.', '.', "END=#{cursor + length - 1};CLASS=INS", "GT:DP:GQ:MIN_DP:PL", "1:200:200:200:800,0,800"]
  else
    raise "I can't even"
  end
end

d.alignments
  .group_by{ |alignment| alignment.refname }
  .sort_by{ |refname, alignments| refname }
  .each do |refname, alignments|
  # We sweep along each of the reference sequences. The cursor tracks
  # our position as we go so we don't concatenate regions that are
  # actually overlapping.
  cursor = 1

  # The =alignments= object is an array of BioMummer::Alignment
  # objects that all match a particular scaffold.
  alignments
    .sort_by{ |alignment| alignment.refstart }.
    each do |aln|
    # Create Bio::Sequence::NA subsequences for the reference and
    # query. They are initially unaligned.
    refSeq = options.ref[aln.refname].subseq(aln.refstart, aln.refstop)
    qrySeq = options.qry[aln.qryname].subseq(aln.qrystart, aln.qrystop)
    qrySeq.complement! unless aln.strand
    
    # Do we have uncovered bases before the alignment starts? These
    # are detected as gaps between the cursor and the alignment start
    # site in the reference.
    gap_size = aln.refstart - cursor
    overlap_size = 0
    if gap_size > 0
      # There is a stretch of reference bases without an alignment
      puts "#{refname}\t#{cursor}\t.\t#{options.ref[refname][cursor].upcase}\t<NON_REF>\t.\t.\tEND=#{aln.refstart - 1}\tGT:DP:GQ:MIN_DP:PL\t0:0:0:0:0,0"
      cursor = aln.refstart
    else
      # There is an overlap between two alignments.
      overlap_size = cursor - aln.refstart + 1
    end

    # Nucmer records insertions and deletions as a series of positive
    # and negative integers corresponding to how many steps along the
    # alignment until you get to the next gap in the reference
    # sequence (positive integer) or how many steps until the next gap
    # in the query (negative integer). BioMummer exposes these as the
    # alignments 'distances' array.
    # We walk along the Bio::Sequence::NA objects and insert gaps
    # (".") when needed. We store our current position in the
    # reference and the query in a two-element array.
    aln.distances.inject([0,0]) do |mem, distance_to_gap|
      if distance_to_gap > 0
        qrySeq.insert(mem[0] + distance_to_gap - 1, ".")
        [mem[0] + distance_to_gap, mem[1] + distance_to_gap]
      else
        refSeq.insert(mem[1] - distance_to_gap - 1, ".")
        [mem[0] - distance_to_gap, mem[1] - distance_to_gap]
      end
    end
    
    # Zip together the sequences which should now be aligned. This
    # returns an array of two-element arrays. The two-element
    # arrays hold a reference base and a query base.
    # These are then grouped by class
    grouped_pairs = refSeq.chars
      .zip(qrySeq.chars)
      .drop_while{ |refBase, qryBase| refBase == '.' ? overlap_size > 0 : (overlap_size-=1) > 0 }
      .chunk do |refBase, qryBase|
      # Classify runs of identiry, insertions, deletions or SNPs.
      if refBase == qryBase
        :NO_VARIATION
      elsif refBase == '.'
        :INSERTION
      elsif qryBase == '.'
        :DELETION
      else
        :SNP
      end
    end.to_a
    next if grouped_pairs.length == 0

    # Indels are reported like this
    #
    # REF: A
    # QRY: AT
    #
    # OR
    #
    # REF: GC
    # QRY: G
    #
    # These require a 1 bp backtrack (to grab the 'A' in the first
    # example) before printing the record. Taking two a time allows us
    # to trim the previous record when an insertion is next-up. If the
    # upcoming variation *is* an insertion, the current set is trimmed
    # and the 'stolen' base is recorded in the =each_with_object= mem
    # array.
    stolen_pair = [[nil],[nil]]
    grouped_pairs.each_cons(2) do |current, upcoming|
      cur_class = current.first
      cur_pairs = current.last
      nxt_class = upcoming.first

      # We might have stolen the only sequence in this chunk. If so,
      # move straight on to the next chunk.
      if nxt_class == :INSERTION || nxt_class == :DELETION
        stolen_pair = cur_pairs.pop
        next if cur_pairs.length == 0
      end

      case cur_class
      when :NO_VARIATION
        puts "#{refname}\t#{cursor}\t.\t#{cur_pairs.first.first.upcase}\t<NON_REF>\t.\t.\tEND=#{(cursor+=cur_pairs.length)-1}\tGT:DP:GQ:MIN_DP:PL\t0:200:200:200:0,800"
      when :SNP
        cur_pairs.each do |refBase, qryBase|
          puts "#{refname}\t#{cursor}\t.\t#{refBase.upcase}\t#{qryBase.upcase},<NON_REF>\t.\t.\tEND=#{(cursor+=1)-1}\tGT:DP:GQ:PL\t1:200:200:800,0,800"
        end
      when :DELETION
        refSeq, qrySeq = cur_pairs.unshift(stolen_pair).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
        puts "#{refname}\t#{cursor}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{(cursor+=refSeq.length) - 1};CLASS=DEL\tGT:DP:GQ:PL\t1:200:200:800,0,800"
      when :INSERTION
        refSeq, qrySeq = cur_pairs.unshift(stolen_pair).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
        puts "#{refname}\t#{cursor}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{(cursor+=refSeq.length) - 1}\tGT:DP:GQ:PL\t1:200:200:800,0,0,800"
      end
    end

    # Print out the last group. We print out the first member of each 
    current = grouped_pairs.last
    cur_class = current.first
    cur_pairs = current.last
    case cur_class
    when :NO_VARIATION
      puts "#{refname}\t#{cursor}\t.\t#{cur_pairs.first.first.upcase}\t<NON_REF>\t.\t.\tEND=#{(cursor+=cur_pairs.length)-1}\tGT:DP:GQ:MIN_DP:PL\t0:200:200:200:0,800"
    when :SNP
      cur_pairs.each do |refBase, qryBase|
        puts "#{refname}\t#{cursor}\t.\t#{refBase.upcase}\t#{qryBase.upcase},<NON_REF>\t.\t.\tEND=#{(cursor+=1)-1}\tGT:DP:GQ:PL\t1:200:200:800,0,800"
      end
    when :DELETION
      refSeq, qrySeq = cur_pairs.unshift(stolen_pair).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
      puts "#{refname}\t#{cursor}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{(cursor+=refSeq.length) - 1}\tGT:DP:GQ:PL\t1:200:200:800,0,800"
    when :INSERTION
      refSeq, qrySeq = cur_pairs.unshift(stolen_pair).transpose.map{|seq| seq.reject{|c|c=='.'}.join.upcase }
      puts "#{refname}\t#{cursor}\t.\t#{refSeq}\t#{qrySeq},<NON_REF>\t.\t.\tEND=#{(cursor+=refSeq.length) - 1}\tGT:DP:GQ:PL\t1:200:200:800,0,0,800"
    end
  end
end
