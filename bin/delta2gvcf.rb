#!/usr/bin/env ruby

require 'stringio'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'tmpdir'
require 'bio-mummer'
require 'bio'

class OptParser
  def self.parse(args)
    options = OpenStruct.new

    opt_parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{File.basename(__FILE__)} [options]"
      opts.separator ""
      opts.separator "Specific options:"

      opts.on("-d", "--delta FILENAME", "Delta file generated by nucmer") do |fn|
        pn = Pathname.new(fn)
        if pn.size?
          options.samplename = pn.basename(".delta")
          options.delta = pn
          match = pn.each_line.first.match(/(?<ref>\/.*) (?<qry>\/.*)/)
          if match
            ref = Pathname.new(match[:ref])
            if ref.size?
              options.ref = Hash[Bio::FlatFile.open(ref).map{|e| [e.entry_id, e.naseq]}]
            end
            
            qry = Pathname.new(match[:qry])
            if qry.size?
              options.qry = Hash[Bio::FlatFile.open(qry).map{|e| [e.entry_id, e.naseq]}]
            end
          end
        else
          $stderr.puts "Error: cannot read file #{fn}"
          exit(1)
        end
      end

      opts.on("-s", "--sample SAMPLENAME", "gVCF Sample name") do |samplename|
        options.samplename = samplename
      end
    end
    opt_parser.parse!(args)
    return options
  end
end
options = OptParser.parse(ARGV)

d = BioMummer::DeltaFile.new(StringIO.new(`delta-filter -r -q #{options.delta}`))

puts '##fileformat=VCFv4.1
##ALT=<ID=NON_REF,Description="Represents any possible alternative allele at this location">
##FILTER=<ID=LowQual,Description="Low quality">
##FORMAT=<ID=AD,Number=.,Type=Integer,Description="Allelic depths for the ref and alt alleles in the order listed">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Approximate read depth (reads with MQ=255 or with bad mates are filtered)">
##FORMAT=<ID=GQ,Number=1,Type=Integer,Description="Genotype Quality">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=MIN_DP,Number=1,Type=Integer,Description="Minimum DP observed within the GVCF block">
##FORMAT=<ID=PL,Number=G,Type=Integer,Description="Normalized, Phred-scaled likelihoods for genotypes as defined in the VCF specification">'

options.ref.each do |name, seq|
  puts "##contig=<ID=#{name},length=#{seq.length}>"
end

puts '##INFO=<ID=BaseQRankSum,Number=1,Type=Float,Description="Z-score from Wilcoxon rank sum test of Alt Vs. Ref base qualities">
##INFO=<ID=ClippingRankSum,Number=1,Type=Float,Description="Z-score From Wilcoxon rank sum test of Alt vs. Ref number of hard clipped bases">
##INFO=<ID=DP,Number=1,Type=Integer,Description="Approximate read depth; some reads may have been filtered">
##INFO=<ID=DS,Number=0,Type=Flag,Description="Were any of the samples downsampled?">
##INFO=<ID=END,Number=1,Type=Integer,Description="Stop position of the interval">
##INFO=<ID=HaplotypeScore,Number=1,Type=Float,Description="Consistency of the site with at most two segregating haplotypes">
##INFO=<ID=InbreedingCoeff,Number=1,Type=Float,Description="Inbreeding coefficient as estimated from the genotype likelihoods per-sample when compared against the Hardy-Weinberg expectation">
##INFO=<ID=MLEAC,Number=A,Type=Integer,Description="Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC), for each ALT allele, in the same order as listed">
##INFO=<ID=MLEAF,Number=A,Type=Float,Description="Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF), for each ALT allele, in the same order as listed">
##INFO=<ID=MQ,Number=1,Type=Float,Description="RMS Mapping Quality">
##INFO=<ID=MQ0,Number=1,Type=Integer,Description="Total Mapping Quality Zero Reads">
##INFO=<ID=MQRankSum,Number=1,Type=Float,Description="Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities">
##INFO=<ID=ReadPosRankSum,Number=1,Type=Float,Description="Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias">
'

puts "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t#{options.samplename}"

def vcf_array(type, refbases, qrybases, refname, cursor, length)
  if refbases.first.nil?
    p type, refbases, qrybases, refname, cursor, length
    raise "I can't even"
  end
  case type
  when :NOVAR
    return [refname, cursor,".", refbases.first.upcase, "<NON_REF>", '.', '.', "END=#{cursor + length - 1}", "GT:DP:GQ:MIN_DP:PL", "0:200:200:200:0,800"]
  when :SNP
    return [refname, cursor,".", refbases.join.upcase, "#{qrybases.join.upcase},<NON_REF>", '.', '.', "END=#{cursor + length - 1};CLASS=SNP", "GT:DP:GQ:MIN_DP:PL", "1:200:200:200:800,0,800"]
  when :DELETION
    return [refname, cursor,".", refbases.join.upcase, "#{qrybases.join.upcase},<NON_REF>", '.', '.', "END=#{cursor + length - 1};CLASS=DEL", "GT:DP:GQ:MIN_DP:PL", "1:200:200:200:800,0,800"]
  when :INSERTION
    return [refname, cursor,".", refbases.join.upcase, "#{qrybases.join.upcase},<NON_REF>", '.', '.', "END=#{cursor + length - 1};CLASS=INS", "GT:DP:GQ:MIN_DP:PL", "1:200:200:200:800,0,800"]
  else
    raise "I can't even"
  end
end

d.alignments
  .group_by{|a| a.refname}.sort_by{|refname, alignments| refname}
  .each do |refname, alignments|
  cursor = 1
  alignments.sort_by{|a| [a.refstart, a.refstop].min}.each do |a|
    ref = options.ref[a.refname].subseq(a.refstart, a.refstop)
    qry = a.strand ? options.qry[a.queryname].subseq(a.querystart, a.querystop) : options.qry[a.queryname].subseq(a.querystart, a.querystop).complement
    if a.refstart > cursor
      puts [refname, cursor, '.', options.ref[refname][cursor-1].upcase, "<NON_REF>", '.', '.', "END=#{a.refstart - 1}", "GT:DP:GQ:MIN_DP:PL", "0:0:0:0:0,0"].join("\t")
      cursor = a.refstart
      overlap = 0
    else
      overlap = cursor - a.refstart
    end
    a.distances.inject([0,0]) do |mem, distance|
      if distance > 0
        qry.insert(mem.first + distance - 1, ".")
        [mem.first + distance, mem.last + distance]
      else
        ref.insert(mem.last - distance - 1, ".")
        [mem.first - distance, mem.last - distance]
      end
    end
    ref.chars.zip(qry.chars)
      .each_with_index
      .drop_while{ |arr, idx| overlap > idx }
      .inject([nil, [],[]]) do |mem, arr_with_idx|
      arr, idx = arr_with_idx
      refbase, qrybase = arr
      case arr.uniq.join
      when /^\..$/ # Insertion in query
        if mem.first == :INSERTION
          mem[2] << arr.last
        elsif mem.first.nil? # We're at the beginning of an alignment
          # so there is no previous base from the pre-fetched
          # alignment to steal, so we go back to the hash to grab the
          # previous base.
          prevBase = options.ref[refname][cursor-2]
          mem = [:INSERTION, [prevBase], [prevBase, arr.last]]
        else
          stolen_base = mem[2].pop.upcase
          puts vcf_array(*mem, refname, cursor, mem[1].length).join("\t") unless mem.first.nil? || mem[2].length <= 0
          cursor += mem[1].length
          mem = [:INSERTION, [stolen_base], [stolen_base, arr.last]]
        end
      when /^.\.$/ # Deletion in query
        if mem.first == :DELETION
          mem[1] << arr.first
        elsif mem.first.nil? # We're at the beginning of an alignment
          # so there is no previous base from the pre-fetched
          # alignment to steal, so we go back to the hash to grab the
          # previous base.
          prevBase = options.ref[refname][cursor-2]
          mem = [:DELETION, [prevBase, arr.first], [prevBase]]
        else
          stolen_base = mem[1].pop.upcase
          puts vcf_array(*mem, refname, cursor, mem[1].length).join("\t") unless mem.first.nil? || mem[1].length <= 0
          cursor += mem[1].length
          mem = [:DELETION, [stolen_base, arr.first], [stolen_base]]
        end
      when /^.$/ # No variation
        if mem.first == :NOVAR
          mem[1] << arr.first
          mem[2] << arr.last
        else
          puts vcf_array(*mem, refname, cursor, mem[1].length).join("\t") unless mem.first.nil?
          mem = [:NOVAR, [arr.first], [arr.last]]
          cursor += mem[1].length
        end
      when /^[^\.][^\.]$/ # A SNP
        if mem.first == :SNP
          mem[1] << arr.first
          mem[2] << arr.last
        else
          puts vcf_array(*mem, refname, cursor, mem[1].length).join("\t") unless mem.first.nil?
          cursor += mem[1].length
          mem = [:SNP, [arr.first], [arr.last]]
        end
      else # Something unexpected
        raise "I can't even"
      end
      mem
    end
  end
end
