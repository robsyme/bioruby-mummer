#!/usr/bin/env ruby

require 'stringio'
require 'optparse'
require 'ostruct'
require 'pathname'
require 'tmpdir'
require 'bio-mummer'
require 'bio'

class OptParser
  def self.parse(args)
    options = OpenStruct.new

    opt_parser = OptionParser.new do |opts|
      opts.banner = "Usage: #{File.basename(__FILE__)} [options]"
      opts.separator ""
      opts.separator "Specific options:"

      opts.on("-d", "--delta FILENAME", "Delta file generated by nucmer") do |fn|
        pn = Pathname.new(fn)
        if pn.size?
          options.delta = pn
          match = pn.each_line.first.match(/(?<ref>\/.*) (?<qry>\/.*)/)
          if match
            ref = Pathname.new(match[:ref])
            if ref.size?
              options.ref = Hash[Bio::FlatFile.open(ref).map{|e| [e.entry_id, e.naseq]}]
            end
            
            qry = Pathname.new(match[:qry])
            if qry.size?
              options.qry = Hash[Bio::FlatFile.open(qry).map{|e| [e.entry_id, e.naseq]}]
            end
          end
        else
          $stderr.puts "Error: cannot read file #{fn}"
          exit(1)
        end
      end
    end
    opt_parser.parse!(args)
    return options
  end
end
options = OptParser.parse(ARGV)

# Open the Delta File
d = BioMummer::DeltaFile.new(StringIO.new(`delta-filter -r -q #{options.delta}`))

puts '##fileformat=VCFv4.1
##ALT=<ID=NON_REF,Description="Represents any possible alternative allele at this location">
##FILTER=<ID=LowQual,Description="Low quality">
##FORMAT=<ID=AD,Number=.,Type=Integer,Description="Allelic depths for the ref and alt alleles in the order listed">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Approximate read depth (reads with MQ=255 or with bad mates are filtered)">
##FORMAT=<ID=GQ,Number=1,Type=Integer,Description="Genotype Quality">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=MIN_DP,Number=1,Type=Integer,Description="Minimum DP observed within the GVCF block">
##FORMAT=<ID=PL,Number=G,Type=Integer,Description="Normalized, Phred-scaled likelihoods for genotypes as defined in the VCF specification">'

options.ref.each do |name, seq|
  puts "##contig=<ID=#{name},length=#{seq.length}>"
end
puts "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tDUMMYSAMPLENAME"

d.alignments.group_by{|a| a.refname}.sort_by{|refname, alignments| refname}.each do |refname, alignments|
  cursor = 1
  overlap = 0
  alignments.sort_by{|a| [a.refstart, a.refstop].min}.each do |a|
    ref = options.ref[a.refname].subseq(a.refstart, a.refstop)
    qry = a.strand ? options.qry[a.queryname].subseq(a.querystart, a.querystop) : options.qry[a.queryname].subseq(a.querystart, a.querystop).complement
    if a.refstart > cursor
      puts [refname, cursor, '.', options.ref[refname][cursor].upcase, "<NON_REF>", '.', '.', "END=#{a.refstart - 1}", "GT:DP:GQ:MIN_DP:PL", "0:0:0:0:0,0"].join("\t")
      cursor = a.refstart
    elsif a.refstart < cursor
      overlap = cursor - a.refstart
    end
    
    a.distances.inject([0,0]) do |mem, distance|
      if distance > 0
        qry.insert(mem.first + distance, ".")
        [mem.first + distance, mem.last + distance]
      else
        ref.insert(mem.last - distance, ".")
        [mem.first - distance, mem.last - distance]
      end
    end

    ref.chars.zip(qry.chars).chunk do |refBase, qryBase|
      if refBase == qryBase
        "NOVAR"
      elsif refBase == "."
        "INS"
      elsif qryBase == "."
        "DEL"
      else
        "SNP"
      end
    end.drop_while do |varClass, arr|
      overlap -= arr.length if varClass != "INS"
      overlap >= 0
    end.each do |varClass, arr|
      case varClass
      when "NOVAR"
        begin
        puts [refname,
              cursor,
              ".",
              options.ref[refname][cursor].upcase,
              "<NON_REF>",
              '.',
              '.',
              "END=#{cursor + arr.length - 1}",
              "GT:DP:GQ:MIN_DP:PL",
              "0:200:200:200:0,800"].join("\t")
        rescue
          $stderr.puts "Error: could not find #{refname}[#{cursor}]"
        end
        
        cursor += arr.length
      when "SNP"
        puts [refname,
              cursor,
              ".",
              arr.map{|a| a.first.upcase}.join,
              [arr.map{|a| a.last.upcase}.join, "<NON_REF>"].join(","),
              '.',
              '.',
              "END=#{cursor + arr.length - 1}",
              "GT:DP:GQ:MIN_DP:PL",
              "1:200:200:200:800,0,800"].join("\t")
        cursor += arr.length
      when "INS"
        refBase = options.ref[refname][cursor].upcase
        puts [refname,
              cursor,
              ".",
              refBase,
              [(refBase + arr.map{|a| a.last}.join).upcase, "<NON_REF>"].join(","),
              '.',
              '.',
              "END=#{cursor + arr.length - 1}",
              "GT:DP:GQ:MIN_DP:PL",
              "1:200:200:200:800,0,800"].join("\t")
      when "DEL"
        puts [refname,
              cursor,
              ".",
              arr.map{|a| a.first.upcase}.join,
              ".,<NON_REF>",
              '.',
              '.',
              "END=#{cursor + arr.length - 1}",
              "GT:DP:GQ:MIN_DP:PL",
              "1:200:200:200:800,0,800"].join("\t")
        cursor += arr.length
      end
    end
  end
end

# Iterate through each hit
#   Outupt a record 
